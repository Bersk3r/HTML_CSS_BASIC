# HTML : HyperText Markup Language, 웹의 구조 + 컨텐츠
# 웹 사이트를 웹 문서과 웹 애플리케이션 중 웹 애플리케이션으로 보는 게 많음
# CSS : Cascading Style Sheet, 디자인
# Javascript : 웹의 동작 (과거) , 웹의 모든 것 (현재)
# document.head.parentNode.removeChild(document.head); =>  CSS가 사라짐 (head에 css를 정의하므로, 완전하게 사라진 것은 아님 = 인라인으로 작성된 부분도 존재하므로)

# HTML은 트리 구조로 되어 있음 (부모-자식-형제, 계층 구조)
# 태그 구조는 하기와 같습니다.
<parent>
    <children>
        <grandchildren>
        <grandchildren>
    </children>
    <sibling>
        <grandchildren>
        <grandchildren>
    </sibling>
</parent>

# HTML은 문법이 엄격하지 않아, body/head에 들어갈 내용이 아무데나 들어가도 동작합
# HTML 내 여는 태그만으로 동작하는 경우, 내부에 들어갈 태그나 내용이 없을 때에 해당됨
=> <meta charset="utf-8" />
=> 여는 태그만 작성해도 동작하더라도 닫는 태그는 반드시 작성할 것
# 시멘틱 태그 : header, nav, main, footer, article, asside, figure와 같이 "div id~"와 동일하나, 의미를 가지는 태그
=> 시멘틱 태그는 웹 제약 사항이 존재함.
=> 이러한 웹 제약 사항을 웹 표준이라고 함.
# CSS 구조는 "속성명: 속성값" 형태이며, 여러 개 일때에는 세미콜론으로 구분 (속성명: 속성값; 속성명2: 속성값2)
# HTML 태그 내에 CSS를 정의하는 것을 인라인 스타일이라고 함. (비권장)
# user agent stylesheet는 브라우저에서 정의한 CSS라고 이해하면 됨
# CSS는 조상/부모 태그에 대한 CSS 속성을 자식 태그가 덮어쓰는 특징을 가지고 있음
# 각 브라우저에서 호환되게 끔 잘 처리하는 것을 크로스 브라우징이라고 부름
# CSS에서 px 단위는 상대적인 단위 (모니터 크기에 따라 달라짐)
=> screen.width / screen.height : 화면의 너비/높이를 보여줌
# CSS에서 선택자와 속성들을 외어야 됨.
# CSS 내 display 속성의 값에는 block, inline-block, inline, none이 있다.
=> block은 너비 100% 차지, inline-block에는 width/height 지정 가능, inline은 컨텐츠의 너비만큼 공간 차지 (margin X)
# HTML 내에서 id는 고유한 값, class는 중복 사용 가능 (또한, 동시 사용도 가능)
=> ex) <div class="blind wook jim" />
# 이미지 한 개에 관련 있는 여러 개의 이미지를 합쳐놓은 것을 이미지 스프라이트라고 함
=> HTTP/2 프로토콜의 등장으로 네트워크 환경이 개선되었으나, 이전에는 이미지 각각 다른 곳에서 가져오는 걸 동시에 하는 게 어려웠음
# CSS 내 background-position은 값이 -이면 왼쪽/위쪽, +이면 오른쪽/아래쪽이 됨.
# CSS 내 background-repeat: no-repeat은 공간이 남아도 반복하여 채우지 않음.
# 박스 구조 (margin : 콘텐츠 바깥 부분, border: 테두리, padding : border와 content 사이의 공간, content : 내용
┌───────margin────────┐
│  ┌─────border─────┐ │
│  │ ┌───padding──┐ │ │
│  │ │  content   │ │ │
│  │ └────────────┘ │ │
│  └────────────────┘ │
└─────────────────────┘
# CSS 내 padding의 속성의 값을 순서대로 작성할 때의 순서는 시계 방향
# CSS 내 border의 값이 상하좌우 다 동일하다면, border : 속성 값 형태로 작성하면 한번에 적용됨
# HTML 내 content, border, padding의 길이를 다 따로 취급함
=> `box-sizing : content-box`는 박스의 크기를 content 길이까지 포함
=> `box-sizing : border-box`는 박스의 크기를 border 길이까지 포함
=> 되도록 모든 태그에 border-box를 적용하는 것이 좋음
# 프로그래머는 중복을 없애야 한다.
# input 태그에 기본적으로 css (box 구조)가 적용되어 있음
=> 브라우저마다 기본 CSS가 다르다. 그렇기에 기본 CSS를 없애는 게 좋다
=> 기본 CSS를 없애는 걸 CSS reset이라고 함, reset.css, normalize.css라는 파일로 많이 사용함
# 색 HEX가 익숙하지 않은 분은 구글에 "hex color"라고 검색하면 나옴
# input 태그의 파란색 테두리를 "outline"이라고 함
=> 브라우저 기본 동작으로 button이나 input에 주로 적용됨, 하지만 있는 게 나을 수 있는데 이유는 마우스가 focus 되어 있는지 확인하기 위한 목적
# input 태그에서 border, padding, outline을 없애는 방법은 각각 none, 0, none으로 설정하면 된다.
# 기본적인 css 틀을 이해한 후에는 외우는 것 밖엔 없다.
# 같은 형제 태그끼리 높낮이가 다를 수 있다.
=> 주로, 서로 height가 다를 때 배치/정렬이 달라짐
=> 세로 정렬 시, vertical-align을 사용하는데, 이 때 display가 inline이나 inline-block일 때만 적용된다.
# blind는 안 보이게 할 세부 요소에만 넣을 것
# CSS에서 부모 자손 관계가 길어진다 싶을 때, ID로 적용하는 것이 좋다.
# span 태그의 display 값은 기본 inline이며, 이는 가로, 세로 크기 조정이 불가능함
# HTML은 적어준 순서대로 화면에 표시됨 (위->아래, 왼쪽->오른쪽)
=> 포지션을 사용하면 기본 흐름을 바꾸는 게 가능함
# 기본적으로 vertical-align은 baseline으로 되어 있음
# input의 display 기본 속성은 inline-block이다. (width, height 적용 가능)
# position에서 absolute를 사용하면, 위치 변경이 가능해진다.
=> top, bottom, left, right 형태로 위치 지정이 가능하다.
# position에서 특정 요소를 기준으로 위치 변경하는 경우, relative를 사용하면 특정 요소를 기반으로 위치 지정이 가능하다.
=> 이 때, position : relative는 기준으로 잡고자 하는 요소에 부여해야 함.
# CSS에서 Containing Block, Block Formatting Context, Stacking Context가 중요하다.
=> Containing Block은 감싸고 있는 태그를 찾으면서 컨테이닝 블록 식별 규칙을 충족해야 한다.
   (숫자로 구성된 속성에 부모-자식 태그 간의 영향을 받음)
=> Block Formatting Context는 Block 구조의 렌더링 순서를 지정하는 규칙 (블록 간 레이아웃 위치 지정)
   (부모 태그 입장에서 자식 태그를 어디까지 포함해야 되는가)
   (조건 : float (float가 none이 아닌 요소), 인라인 블록 (display: inline-block), overflow가 visible이 아닌 요소, 절대 위치로 지정된 요소 (position이 absolute나 fixed인 요소), flex box (display: flex 혹은 inline-flex인 요소))
=> Stacking Context는 특정 DIV의 렌더링 순서를 지정하는 규칙 (태그끼리 겹치는 순서 지정)
=> 목적은 원하는 위치에 태그를 배치하고자 할 때 중요함
# HTML은 모바일, 태블릿 간의 배치, 크로스 브라우징에 따라 화면 구조가 변경될 수 있다.
=> 화면 만들 때, 여러 가지 브라우저 테스트가 필수적임.
# MDN에 있는 문서는 공식 문서는 아니나, 다른 글보다는 정확하다.
# 기본적으로 모든 태그는 position 속성이 static으로 설정돼있음
# CSS 속성 중 position 값이 static, relative, absolute, fixed이 되면 상하좌우로 흐름을 바꿀 수 있음
=> relative는 position이 static일 때의 위치를 기준으로 변경
=> absolute는 컨테이닝 블록의 위치를 기준으로 변경, absolute의 컨테이닝 블록음 계속 부모 태그를 올라가 position 속성이 static이 아닌 부모 태그임
   (html 태그가 컨테이닝 블록임, 위치가 변경되는 경우는 right, top 등과 같은 속성을 적용했을 때, 이외에는 모두 태그 위치 기준 동작)
   (top, right, bottom, left가 없어도 absolute는 기본 배치 흐름에서 벗어남)
   (position 속성이 absolute인 경우, 자신의 컨테이닝 블록이 어디인지 알아야 함)
=> fixed는 화면이 바뀌어도 그 위치에 고정되서 있는 것을 의미
   (fixed도 absolute와 동일하게 자신의 컨테이닝 블록이 어디인지 알아야 함)
   (fixed는 주로 컨테이닝 블록이 뷰 포트나 페이지 영역임)
# width랑 height를 %로 주는 경우, 컨테이닝 블록을 기준으로 몇%인지 정해진다.
# 조상의 display 속성이 inline인 경우, 컨테이닝 블록이 될 수 없음
# button 태그는 기본적으로 세로 가운데 정렬을 함.
# 이미지 스프라이트는 귀찮으나, 하나씩 이미지를 삽입해야 함.
# 실무에선 nth-child 최대한 안쓰는 게 좋음
=> 순서에 의존적인 속성은 유지보수가 어려움
# CSS에서 덮어쓰임이 적용되면 기존 적용 속성에 취소 선이 표시되기도 함.
# CSS의 우선 순위
=> 기본적으로 뒤에 나오는 CSS가 우선 순위가 높음
=> !important > inline style attribute > id > 다른 attribute, class, pseudo 클래스(:first-child 등) > tag element, psuedo 엘리먼트(::berfore 등) 순으로 우선 순위가 높음
=> 우선 순위가 같은 경우, 갯수가 많은 CSS가 우선 순위가 높음
# float은 둥둥 떠있는 상태이므로, 공간에 그 다음 콘텐츠가 들어감.
=> 컨텐츠끼리 겹치지는 않음, 다만 컨텐츠를 피함.
=> overflow 값은 기본 visible이다.
(overflow 값이 visible인 경우, 블록 포맷 컨텍스트가 아니므로, float이 넘침)
(overflow 값이 auto인 경우, 자식 태그의 높이가 부모 태그보다 긴 경우 (넘치는 경우), scollbar를 생성)
(overflow 값이 hidden인 경우, 자식 태그의 높이가 부모 태그보다 길면 길이 차만큼 잘라버림)

